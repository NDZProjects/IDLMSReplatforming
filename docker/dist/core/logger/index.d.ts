declare const _default: {
    info: (msg: any, ...args: any[]) => import("winston").Logger;
    warn: (msg: any, ...args: any[]) => import("winston").Logger;
    error: (msg: any, ...args: any[]) => void;
    debug: (msg: any, ...args: any[]) => import("winston").Logger;
    silent: boolean;
    format: import("logform").Format;
    levels: import("winston/lib/winston/config").AbstractConfigSetLevels;
    level: string;
    transports: {
        format?: import("logform").Format;
        level?: string;
        silent?: boolean;
        handleExceptions?: boolean;
        handleRejections?: boolean;
        log?(info: any, next: () => void): any;
        logv?(info: any, next: () => void): any;
        close?(): void;
        readonly writable: boolean;
        readonly writableEnded: boolean;
        readonly writableFinished: boolean;
        readonly writableHighWaterMark: number;
        readonly writableLength: number;
        readonly writableObjectMode: boolean;
        readonly writableCorked: number;
        destroyed: boolean;
        readonly closed: boolean;
        readonly errored: Error | null;
        readonly writableNeedDrain: boolean;
        _write(chunk: any, encoding: BufferEncoding, callback: (error?: Error | null) => void): void;
        _writev?(chunks: Array<{
            chunk: any;
            encoding: BufferEncoding;
        }>, callback: (error?: Error | null) => void): void;
        _construct?(callback: (error?: Error | null) => void): void;
        _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
        _final(callback: (error?: Error | null) => void): void;
        write(chunk: any, callback?: (error: Error | null | undefined) => void): boolean;
        write(chunk: any, encoding: BufferEncoding, callback?: (error: Error | null | undefined) => void): boolean;
        setDefaultEncoding(encoding: BufferEncoding): any;
        end(cb?: () => void): any;
        end(chunk: any, cb?: () => void): any;
        end(chunk: any, encoding: BufferEncoding, cb?: () => void): any;
        cork(): void;
        uncork(): void;
        destroy(error?: Error): any;
        addListener(event: "close", listener: () => void): any;
        addListener(event: "drain", listener: () => void): any;
        addListener(event: "error", listener: (err: Error) => void): any;
        addListener(event: "finish", listener: () => void): any;
        addListener(event: "pipe", listener: (src: import("stream").Readable) => void): any;
        addListener(event: "unpipe", listener: (src: import("stream").Readable) => void): any;
        addListener(event: string | symbol, listener: (...args: any[]) => void): any;
        emit(event: "close"): boolean;
        emit(event: "drain"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "finish"): boolean;
        emit(event: "pipe", src: import("stream").Readable): boolean;
        emit(event: "unpipe", src: import("stream").Readable): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "close", listener: () => void): any;
        on(event: "drain", listener: () => void): any;
        on(event: "error", listener: (err: Error) => void): any;
        on(event: "finish", listener: () => void): any;
        on(event: "pipe", listener: (src: import("stream").Readable) => void): any;
        on(event: "unpipe", listener: (src: import("stream").Readable) => void): any;
        on(event: string | symbol, listener: (...args: any[]) => void): any;
        once(event: "close", listener: () => void): any;
        once(event: "drain", listener: () => void): any;
        once(event: "error", listener: (err: Error) => void): any;
        once(event: "finish", listener: () => void): any;
        once(event: "pipe", listener: (src: import("stream").Readable) => void): any;
        once(event: "unpipe", listener: (src: import("stream").Readable) => void): any;
        once(event: string | symbol, listener: (...args: any[]) => void): any;
        prependListener(event: "close", listener: () => void): any;
        prependListener(event: "drain", listener: () => void): any;
        prependListener(event: "error", listener: (err: Error) => void): any;
        prependListener(event: "finish", listener: () => void): any;
        prependListener(event: "pipe", listener: (src: import("stream").Readable) => void): any;
        prependListener(event: "unpipe", listener: (src: import("stream").Readable) => void): any;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): any;
        prependOnceListener(event: "close", listener: () => void): any;
        prependOnceListener(event: "drain", listener: () => void): any;
        prependOnceListener(event: "error", listener: (err: Error) => void): any;
        prependOnceListener(event: "finish", listener: () => void): any;
        prependOnceListener(event: "pipe", listener: (src: import("stream").Readable) => void): any;
        prependOnceListener(event: "unpipe", listener: (src: import("stream").Readable) => void): any;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): any;
        removeListener(event: "close", listener: () => void): any;
        removeListener(event: "drain", listener: () => void): any;
        removeListener(event: "error", listener: (err: Error) => void): any;
        removeListener(event: "finish", listener: () => void): any;
        removeListener(event: "pipe", listener: (src: import("stream").Readable) => void): any;
        removeListener(event: "unpipe", listener: (src: import("stream").Readable) => void): any;
        removeListener(event: string | symbol, listener: (...args: any[]) => void): any;
        pipe<T extends NodeJS.WritableStream>(destination: T, options?: {
            end?: boolean | undefined;
        }): T;
        compose<T extends NodeJS.ReadableStream>(stream: T | ((source: any) => void) | Iterable<T> | AsyncIterable<T>, options?: {
            signal: AbortSignal;
        }): T;
        [EventEmitter.captureRejectionSymbol]?<K>(error: Error, event: string | symbol, ...args: any[]): void;
        off<K>(eventName: string | symbol, listener: (...args: any[]) => void): any;
        removeAllListeners(eventName?: string | symbol): any;
        setMaxListeners(n: number): any;
        getMaxListeners(): number;
        listeners<K>(eventName: string | symbol): Function[];
        rawListeners<K>(eventName: string | symbol): Function[];
        listenerCount<K>(eventName: string | symbol, listener?: Function): number;
        eventNames(): (string | symbol)[];
    }[];
    exceptions: import("winston").ExceptionHandler;
    rejections: import("winston").RejectionHandler;
    profilers: object;
    exitOnError: Function | boolean;
    defaultMeta?: any;
    log: import("winston").LogMethod;
    help: import("winston").LeveledLogMethod;
    data: import("winston").LeveledLogMethod;
    prompt: import("winston").LeveledLogMethod;
    http: import("winston").LeveledLogMethod;
    verbose: import("winston").LeveledLogMethod;
    input: import("winston").LeveledLogMethod;
    silly: import("winston").LeveledLogMethod;
    emerg: import("winston").LeveledLogMethod;
    alert: import("winston").LeveledLogMethod;
    crit: import("winston").LeveledLogMethod;
    warning: import("winston").LeveledLogMethod;
    notice: import("winston").LeveledLogMethod;
    writable: boolean;
    writableEnded: boolean;
    writableFinished: boolean;
    writableHighWaterMark: number;
    writableLength: number;
    writableObjectMode: boolean;
    writableCorked: number;
    writableNeedDrain: boolean;
    closed: boolean;
    errored: Error | null;
    allowHalfOpen: boolean;
    readableAborted: boolean;
    readable: boolean;
    readableDidRead: boolean;
    readableEncoding: BufferEncoding | null;
    readableEnded: boolean;
    readableFlowing: boolean | null;
    readableHighWaterMark: number;
    readableLength: number;
    readableObjectMode: boolean;
    destroyed: boolean;
    off<K>(eventName: string | symbol, listener: (...args: any[]) => void): import("winston").Logger;
    removeAllListeners(eventName?: string | symbol): import("winston").Logger;
    setMaxListeners(n: number): import("winston").Logger;
    getMaxListeners(): number;
    listeners<K>(eventName: string | symbol): Function[];
    rawListeners<K>(eventName: string | symbol): Function[];
    listenerCount<K>(eventName: string | symbol, listener?: Function): number;
    eventNames(): (string | symbol)[];
};
export default _default;
